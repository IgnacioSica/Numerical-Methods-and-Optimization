<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Actividad $A_3$.</title>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] },
  TeX: { equationNumbers: { autoNumber: 'all' } }
});
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<style>
body > * {
  max-width: 42em;
}
body {
  font-family: "Roboto Condensed", sans-serif;
  padding-left: 7.5em;
  padding-right: 7.5em;
}
pre, code {
  max-width: 50em;
  font-family: monospace;
}
pre.oct-code {
  border: 1px solid Grey;
  padding: 5px;
}
pre.oct-code-output {
  margin-left: 2em;
}
span.comment {
  color: ForestGreen;
}
span.keyword {
  color: Blue;
}
span.string {
  color: DarkOrchid;
}
footer {
  margin-top: 2em;
  font-size: 80%;
}
a, a:visited {
  color: Blue;
}
h2 {
  font-family: "Roboto Condensed", serif;
  margin-top: 1.5em;
}
h2 a, h2 a:visited {
  color: Black;
}
</style>

</head>
<body>
<h1>Actividad $A_3$.</h1>

<p><b>Algebra Lineal, Métodos Iterativos</b></p>

<p>Ignacio Sica</p>

<p>24/04/21</p>

<h2>Contents</h2>
<ul>
<li><a href="#node1">Programe los siguientes algoritmos:</a></li>
<li><a href="#node2">Ejercicio n#1</a></li>
<li><a href="#node3">Ejercicio n#2</a></li>
<li><a href="#node4">Bibliografia</a></li>
<li><a href="#node5">Jacobi</a></li>
<li><a href="#node6">SOR</a></li>
<li><a href="#node7">Gradiente conjugado</a></li>
<li><a href="#node8">SustitucionAdelante</a></li>
<li><a href="#node9">SustitucionAtras</a></li>
<li><a href="#node10">Codigo ej1</a></li>
<li><a href="#node11">Codigo ej2</a></li>
</ul>
<h2><a id="node1">Programe los siguientes algoritmos:</a></h2>
<p>Algoritmo de Jacobi para la solución de sistemas de ecuaciones lineales.</p>

<p>Algoritmo de Sobre relajación sucesiva (SOR) para la solución de sistemas de
ecuaciones lineales.</p>

<p>Algoritmo de gradiente conjugado para la solución de sistemas de ecuaciones
lineales (Tabla 3.1; Walter 2014)</p>

<pre class="oct-code">load datos1
load datos2

a = {a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14};
b = {b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14};</pre>
<h2><a id="node2">Ejercicio n#1</a></h2>
<p>Utilizando el archivo datos1 resolver los sistemas de ecuaciones $a_ix_i=b_i$,
para i=1,2,...,5, con los algoritmos de Jacobi, SOR con ?=0.5,1,1.5 y Gradiente
Conjugado. Compare los errores relativos con respecto a los vectores bi y el
tiempo de solución necesario. Comente sus resultados.</p>

<pre class="oct-code">tol      = 0.00000001;
max_iter = 250;

<span class="keyword">for</span> i = 1 : 5
  printf(<span class="string">"a%d: "</span>, i), disp(<span class="string">""</span>)
  ej1(a{i}, b{i}, tol, max_iter);
  disp(<span class="string">""</span>)
<span class="keyword">endfor</span></pre>

<pre class="oct-code-output">a1: 
Jacobi:
  Time elapsed: 0.000320911s
  Error: 3.44529e-09
  Total iterations: 10
SOR 0.5:
  Time elapsed: 0.00363684s
  Error: 6.9108e-09
  Total iterations: 24
SOR 1.0:
  Time elapsed: 0.00364614s
  Error: 6.9108e-09
  Total iterations: 24
SOR 1.5:
  Time elapsed: 0.00336504s
  Error: 6.9108e-09
  Total iterations: 24
Gradiente Conjugado:
  Time elapsed: 0.00206089s
  Error: 3.24057e-18
  Total iterations: 5
 
a2: 
Jacobi:
  Time elapsed: 0.000381947s
  Error: 6.37666e-09
  Total iterations: 20
SOR 0.5:
  Time elapsed: 0.00914907s
  Error: 9.57453e-09
  Total iterations: 37
SOR 1.0:
  Time elapsed: 0.00914192s
  Error: 9.57453e-09
  Total iterations: 37
SOR 1.5:
  Time elapsed: 0.0089612s
  Error: 9.57453e-09
  Total iterations: 37
Gradiente Conjugado:
  Time elapsed: 0.00281215s
  Error: 8.44988e-10
  Total iterations: 9
 
a3: 
Jacobi:
  Time elapsed: 0.0039959s
  Error: 3.74185e+59
  Total iterations: 250
SOR 0.5:
  Time elapsed: 0.0229161s
  Error: 0.000306486
  Total iterations: 250
SOR 1.0:
  Time elapsed: 0.0231819s
  Error: 0.000306486
  Total iterations: 250
SOR 1.5:
  Time elapsed: 0.0233068s
  Error: 0.000306486
  Total iterations: 250
Gradiente Conjugado:
  Time elapsed: 0.00120091s
  Error: 5.80399e-13
  Total iterations: 3
 
a4: 
Jacobi:
  Time elapsed: 0.00406003s
  Error: 3.26471e+103
  Total iterations: 250
SOR 0.5:
  Time elapsed: 0.0289621s
  Error: 0.000111675
  Total iterations: 250
SOR 1.0:
  Time elapsed: 0.02895s
  Error: 0.000111675
  Total iterations: 250
SOR 1.5:
  Time elapsed: 0.0288641s
  Error: 0.000111675
  Total iterations: 250
Gradiente Conjugado:
  Time elapsed: 0.00149608s
  Error: 2.74776e-09
  Total iterations: 4
 
a5: 
Jacobi:
  Time elapsed: 0.0040729s
  Error: 6.51548e+134
  Total iterations: 250
SOR 0.5:
  Time elapsed: 0.0345919s
  Error: 6.64863e-05
  Total iterations: 250
SOR 1.0:
  Time elapsed: 0.0346479s
  Error: 6.64863e-05
  Total iterations: 250
SOR 1.5:
  Time elapsed: 0.0348909s
  Error: 6.64863e-05
  Total iterations: 250
Gradiente Conjugado:
  Time elapsed: 0.00240493s
  Error: 7.18619e-14
  Total iterations: 7
 
</pre>

<p>Comentarios sobre resultados</p>
<h2><a id="node3">Ejercicio n#2</a></h2>
<p>Utilizando el archivo datos2  resolver los sistemas de ecuaciones $a_ix_i=b_i$,
para i=3,...,14, utilizando la descomposición PLU. Calcule los errores
relativos con respecto a los vectores bi, los errores relativos con respecto
a la solución verdadera en todos los casos que es un vector de unos en todas
las entradas, calculo los números de condición de los sistemas (que coincidan
con la definición del libro) y concluya si los resultados obtenidos se pueden
explicar con esta información. Justifique sus conclusiones.</p>

<pre class="oct-code"><span class="keyword">for</span> i = 3 : 13
  printf(<span class="string">"a%d: "</span>, i), disp(<span class="string">""</span>)
  ej2(a{i}, b{i});
  disp(<span class="string">""</span>)
<span class="keyword">endfor</span></pre>

<pre class="oct-code-output">a3: 
  PLU
  Time elapsed: 0.000777006s
  Error 1: 0
  Error 2: 6.313e-16
  Cifras significativas: 14
 
a4: 
  PLU
  Time elapsed: 0.000601053s
  Error 1: 0
  Error 2: 1.51191e-13
  Cifras significativas: 12
 
a5: 
  PLU
  Time elapsed: 0.000769854s
  Error 1: 1.62117e-16
  Error 2: 3.70729e-13
  Cifras significativas: 12
 
a6: 
  PLU
  Time elapsed: 0.000966072s
  Error 1: 8.964e-17
  Error 2: 2.48618e-10
  Cifras significativas: 9
 
a7: 
  PLU
  Time elapsed: 0.00115705s
  Error 1: 6.46991e-17
  Error 2: 1.29741e-08
  Cifras significativas: 7
 
a8: 
  PLU
  Time elapsed: 0.00137806s
  Error 1: 6.55824e-17
  Error 2: 1.19995e-07
  Cifras significativas: 6
 
a9: 
  PLU
  Time elapsed: 0.00162101s
  Error 1: 8.29979e-17
  Error 2: 1.46937e-05
  Cifras significativas: 4
 
a10: 
  PLU
  Time elapsed: 0.00186801s
  Error 1: 1.20196e-16
  Error 2: 0.000267894
  Cifras significativas: 3
 
a11: 
  PLU
  Time elapsed: 0.002141s
  Error 1: 1.24396e-16
  Error 2: 0.000506984
  Cifras significativas: 2
 
a12: 
  PLU
  Time elapsed: 0.00257111s
  Error 1: 1.20395e-16
  Error 2: 0.148813
  Cifras significativas: 0
 
a13: 
  PLU
  Time elapsed: 0.00289416s
  Error 1: 2.05618e-16
  Error 2: 7.2455
  Cifras significativas: -2
 
</pre>

<p>Comentarios sobre resultados</p>
<h2><a id="node4">Bibliografia</a></h2>
<p><b>Eric Walter</b>, Springer, Numerical Methods and Optimization</p>

<p><b>Richard Khoury</b> &amp; Douglas Wilhelm Harder, Springer
    Numerical Methods and Modelling for Engineering</p>

<p><b>Gauss–Seidel method</b>, Wikipedia,
    (https://en.wikipedia.org/wiki/Gauss%E2%80%93Seidel_method)</p>

<p><b>Norm (mathematics)</b>, Wikipedia
    (https://en.wikipedia.org/wiki/Norm_(mathematics))</p>

<p><b>Javier Segura</b>, Universidad de Cantabria, Introduccion al analisis numerico
    (https://personales.unican.es/segurajj/intro.pdf)</p>

<p><b>Errors for Linear Systems</b>
    (http://terpconnect.umd.edu/~petersd/460/linsysterrn.pdf)</p>

<p><b>Inv Function</b>
    (https://octave.sourceforge.io/octave/function/inv.html)</p>
<h2><a id="node5">Jacobi</a></h2>
<pre class="pre-code"><span class="keyword">function</span> [X_sol,err,total_iter] = jacobi (A, b, X0, tol, Max_iter)
  err = 10;
  contador = 0;
  D = diag(diag(A));
  M1 = A-D;
  Dinv = diag( 1./diag(A) );
  <span class="keyword">while</span> err&gt;tol &amp;&amp; contador&lt;Max_iter
    X1 = Dinv*(-M1*X0 + b);
    err = norm(X1-X0);
    contador = contador + 1;
    X0 = X1;
  <span class="keyword">endwhile</span>
  X_sol = X1;
  total_iter = contador;
<span class="keyword">endfunction</span>
</pre>
<h2><a id="node6">SOR</a></h2>
<pre class="pre-code"><span class="keyword">function</span> [X_sol,err,total_iter] = SOR (A, b, X0, om, tolerance, max_iter)
  
  D = diag(diag(A));
  L = tril(A, -1);
  U = triu(A, +1);
  
  err = 10;
  counter = 0;
  
  <span class="keyword">while</span> err &gt; tolerance &amp;&amp; counter &lt; max_iter
    
    X1 = SustitucionAdelante(D + om * L, om * b - (om * U + (om -1) * D) * X0);
    
    err = norm(X1-X0);
    counter = counter + 1;
    X0 = X1;
    
  <span class="keyword">endwhile</span>
  
  X_sol = X1;
  total_iter = counter;
  
<span class="keyword">endfunction</span></pre>
<h2><a id="node7">Gradiente conjugado</a></h2>
<pre class="pre-code"><span class="keyword">function</span> [x_sol, err, total_iter] = GC (A, b, x, tolerance, max_iter)
  
  err = 10;
  counter = 0;
  
  r   = b - A * x;
  d   = r;
  sig_0 = normest(r)^2;
  k     = 0;
  
  <span class="keyword">while</span> normest(r) &gt; tolerance &amp;&amp; k &lt; max_iter
    
    sig_a = d<span class="string">' * (A * d);</span>
    lam = sig_0 / sig_a;
    x = x + lam * d;
    r = r - lam * A * d;
    sig_1 = normest(r)^2;
    bet = sig_1 / sig_0;
    d = r + bet * d;
    sig_0 = sig_1;
    k = k + 1;
    
  <span class="keyword">endwhile</span>
  
  x_sol = x;
  err = normest(r);
  total_iter = k;
  
<span class="keyword">endfunction</span></pre>
<h2><a id="node8">SustitucionAdelante</a></h2>
<pre class="pre-code"><span class="keyword">function</span> [y,msg] = SustitucionAdelante (L, b)
  [mL,nL] = size(L);
  [mb,nb] = size(b);
  
  <span class="comment">## </span>
  <span class="keyword">if</span> mL ~= nL
    msg = 0;
    y = inf;
    disp(<span class="string">'L no es cuadrada'</span>)
    return; <span class="comment"># fin de la funcion</span>
  <span class="keyword">elseif</span> (mL ~= mb) || nb ~= 1
    msg = 0;
    y = inf;
    disp(<span class="string">'L y b son de dimensiones incompatibles'</span>)
    return; <span class="comment"># fin de la funcion</span>
  <span class="keyword">endif</span>
  <span class="keyword">for</span> ii=1:mL
    <span class="keyword">if</span> abs(L(ii,ii)) &lt; eps
      msg = 0;
      y = inf;
      disp(<span class="string">'L tiene pivote menor que eps'</span>)
      return; <span class="comment"># fin de la funcion</span>
    <span class="keyword">endif</span>
  <span class="keyword">endfor</span>
  
  <span class="comment">## Inicio del algoritmo</span>
  y = 0*b; 
  
  <span class="keyword">if</span> (L(1,1)==1)
    y(1) = b(1);
  <span class="keyword">else</span>
    y(1) = b(1)/L(1,1);
  <span class="keyword">endif</span>
  <span class="keyword">for</span> ii=2:mL
    y(ii) = b(ii)-L(ii,1:ii-1)*y(1:ii-1);
    pivote = L(ii,ii);
    <span class="keyword">if</span> (pivote ~=1)
      y(ii) = y(ii)/pivote;
    <span class="keyword">endif</span>
  <span class="keyword">endfor</span>
  
  msg = 1; 
 <span class="comment">% disp('Algoritmo finalizo normalmente');  </span>
    
  <span class="keyword">endfunction</span>
  </pre>
<h2><a id="node9">SustitucionAtras</a></h2>
<pre class="pre-code"><span class="keyword">function</span> [y,msg] = SustitucionAtras (U, b)
  [mU,nU] = size(U);
  [mb,nb] = size(b);
  
  <span class="keyword">if</span> mU ~= nU
    msg = 0;
    y = inf;
    disp(<span class="string">'U no es cuadrada'</span>)
    return; <span class="comment"># fin de la funcion</span>
  <span class="keyword">elseif</span> (mU ~= mb) || nb ~= 1
    msg = 0;
    y = inf;
    disp(<span class="string">'U y b son de dimensiones incompatibles'</span>)
    return; <span class="comment"># fin de la funcion</span>
  <span class="keyword">endif</span>
  <span class="keyword">for</span> ii=1:mU
    <span class="keyword">if</span> abs(U(ii,ii)) &lt; eps
      msg = 0;
      y = inf;
      disp(<span class="string">'U tiene pivote menor que eps'</span>)
      return; <span class="comment"># fin de la funcion</span>
    <span class="keyword">endif</span>
  <span class="keyword">endfor</span>
  
  <span class="comment">## Inicio del algoritmo</span>
  y = 0*b; 
  
  <span class="keyword">if</span> (U(end,end)==1)
    y(end) = b(end);
  <span class="keyword">else</span>
    y(end) = b(end)/U(end,end);
  <span class="keyword">endif</span>
  <span class="keyword">for</span> ii=1:nU-1
    y(nU-ii) = b(nU-ii)-U(nU-ii,nU-ii:end)*y(nU-ii:end);
    pivote = U(nU-ii,nU-ii);
    <span class="keyword">if</span> (pivote ~=1)
      y(nU-ii) = y(nU-ii)/pivote;
    <span class="keyword">endif</span>
  <span class="keyword">endfor</span>
  
  msg = 1; 
 <span class="comment">% disp('Algoritmo finalizo normalmente');  </span>
    
<span class="keyword">endfunction</span></pre>
<h2><a id="node10">Codigo ej1</a></h2>
<pre class="pre-code"><span class="keyword">function</span> ej1 (A, b, tol, Max_iter)
  x = zeros(size(b));
  disp(<span class="string">"Jacobi:"</span>)
  tic();
  [x_sol_jacobi,err,total_iter] = jacobi (A, b, x, tol, Max_iter);
  time = toc ();
  printf(<span class="string">"  Time elapsed: %ds"</span>, time), disp(<span class="string">""</span>)
  x_sol_jacobi;
  err;
  printf(<span class="string">"  Error: %d"</span>, err), disp(<span class="string">""</span>)
  total_iter;
  printf(<span class="string">"  Total iterations: %d"</span>, total_iter), disp(<span class="string">""</span>)
  
  disp(<span class="string">"SOR 0.5:"</span>)
  tic();
  [x_sol_sor_05,err,total_iter] = SOR(A, b, x, 0.5, tol, Max_iter);
  time = toc ();
  printf(<span class="string">"  Time elapsed: %ds"</span>, time), disp(<span class="string">""</span>)
  x_sol_sor_05;
  err;
  printf(<span class="string">"  Error: %d"</span>, err), disp(<span class="string">""</span>)
  total_iter;
  printf(<span class="string">"  Total iterations: %d"</span>, total_iter), disp(<span class="string">""</span>)
  
  disp(<span class="string">"SOR 1.0:"</span>)
  tic();
  [x_sol_sor_10,err,total_iter] = SOR(A, b, x, 0.5, tol, Max_iter);
  time = toc ();
  printf(<span class="string">"  Time elapsed: %ds"</span>, time), disp(<span class="string">""</span>)
  x_sol_sor_10;
  err;
  printf(<span class="string">"  Error: %d"</span>, err), disp(<span class="string">""</span>)
  total_iter;
  printf(<span class="string">"  Total iterations: %d"</span>, total_iter), disp(<span class="string">""</span>)
  
  disp(<span class="string">"SOR 1.5:"</span>)
  tic();
  [x_sol_sor_15,err,total_iter] = SOR(A, b, x, 0.5, tol, Max_iter);
  time = toc ();
  printf(<span class="string">"  Time elapsed: %ds"</span>, time), disp(<span class="string">""</span>)
  x_sol_sor_15;
  err;
  printf(<span class="string">"  Error: %d"</span>, err), disp(<span class="string">""</span>)
  total_iter;
  printf(<span class="string">"  Total iterations: %d"</span>, total_iter), disp(<span class="string">""</span>)
  
  disp(<span class="string">"Gradiente Conjugado:"</span>)
  tic();
  [x_sol_gc,err,total_iter] = GC(A, b, x, tol, Max_iter);
  time = toc ();
  printf(<span class="string">"  Time elapsed: %ds"</span>, time), disp(<span class="string">""</span>)
  x_sol_gc;
  err;
  printf(<span class="string">"  Error: %d"</span>, err), disp(<span class="string">""</span>)
  total_iter;
  printf(<span class="string">"  Total iterations: %d"</span>, total_iter), disp(<span class="string">""</span>)
<span class="keyword">endfunction</span></pre>
<h2><a id="node11">Codigo ej2</a></h2>
<pre class="pre-code"><span class="keyword">function</span> ej2 (A, b)
  
  disp (<span class="string">"  PLU"</span>)
  tic();
  y = sem_plu(A, b);
  time = toc ();
  printf(<span class="string">"  Time elapsed: %ds"</span>, time), disp(<span class="string">""</span>)
  error = norm(A * y - b) / norm(b);
  printf(<span class="string">"  Error 1: %d"</span>, error),
  disp (<span class="string">""</span>)
  sol = ones(size(y),1);
  error = norm(y - sol) / norm(sol);
  printf(<span class="string">"  Error 2: %d"</span>, error),
  disp (<span class="string">""</span>)
  Sd=floor(-log10(error/0.5));
  printf(<span class="string">"  Cifras significativas: %d"</span>, Sd),
  disp(<span class="string">""</span>)
  

<span class="keyword">endfunction</span></pre>

<footer>
<hr>
<a href="https://www.octave.org">Published with GNU Octave 6.2.0</a>
</footer>
<!--
##### SOURCE BEGIN #####
%% Actividad $A_3$.
% *Algebra Lineal, Métodos Iterativos*
%
% Ignacio Sica
%
% 24/04/21

%% Programe los siguientes algoritmos:
% Algoritmo de Jacobi para la solución de sistemas de ecuaciones lineales.
%
% Algoritmo de Sobre relajación sucesiva (SOR) para la solución de sistemas de
% ecuaciones lineales.
%
% Algoritmo de gradiente conjugado para la solución de sistemas de ecuaciones
% lineales (Tabla 3.1; Walter 2014)

load datos1
load datos2

a = {a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14};
b = {b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14};

%% Ejercicio n#1
% Utilizando el archivo datos1 resolver los sistemas de ecuaciones $a_ix_i=b_i$,
% para i=1,2,...,5, con los algoritmos de Jacobi, SOR con ?=0.5,1,1.5 y Gradiente
% Conjugado. Compare los errores relativos con respecto a los vectores bi y el
% tiempo de solución necesario. Comente sus resultados.

tol      = 0.00000001;
max_iter = 250;

for i = 1 : 5
  printf("a%d: ", i), disp("")
  ej1(a{i}, b{i}, tol, max_iter);
  disp("")
endfor

%%
% Comentarios sobre resultados

%% Ejercicio n#2
% Utilizando el archivo datos2  resolver los sistemas de ecuaciones $a_ix_i=b_i$,
% para i=3,...,14, utilizando la descomposición PLU. Calcule los errores
% relativos con respecto a los vectores bi, los errores relativos con respecto
% a la solución verdadera en todos los casos que es un vector de unos en todas
% las entradas, calculo los números de condición de los sistemas (que coincidan
% con la definición del libro) y concluya si los resultados obtenidos se pueden
% explicar con esta información. Justifique sus conclusiones.

for i = 3 : 13
  printf("a%d: ", i), disp("")
  ej2(a{i}, b{i});
  disp("")
endfor

%%
% Comentarios sobre resultados

%% Bibliografia
% *Eric Walter*, Springer, Numerical Methods and Optimization
%
% *Richard Khoury* & Douglas Wilhelm Harder, Springer
%     Numerical Methods and Modelling for Engineering
%
% *Gauss–Seidel method*, Wikipedia,
%     (https://en.wikipedia.org/wiki/Gauss%E2%80%93Seidel_method)
%
% *Norm (mathematics)*, Wikipedia
%     (https://en.wikipedia.org/wiki/Norm_(mathematics))
%
% *Javier Segura*, Universidad de Cantabria, Introduccion al analisis numerico
%     (https://personales.unican.es/segurajj/intro.pdf)
%
% *Errors for Linear Systems*
%     (http://terpconnect.umd.edu/~petersd/460/linsysterrn.pdf)
%
% *Inv Function*
%     (https://octave.sourceforge.io/octave/function/inv.html)
%

%% Jacobi
# <include>jacobi.m</include>

%% SOR
# <include>SOR.m</include>

%% Gradiente conjugado
# <include>GC.m</include>

%% SustitucionAdelante
# <include>SustitucionAdelante.m</include>

%% SustitucionAtras
# <include>SustitucionAtras.m</include>

%% Codigo ej1
# <include>ej1.m</include>

%% Codigo ej2
# <include>ej2.m</include>
##### SOURCE END #####
-->
</body>
</html>
